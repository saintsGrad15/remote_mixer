<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Remote Mixer</title>
    <style lang="css">
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            background-color: #2a2a2a;
            color: #fff;
            overflow: hidden;
            height: 100vh;
        }

        #header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background-color: #007bff;
            color: white;
            padding: 15px;
            text-align: center;
            font-size: 20px;
            font-weight: bold;
            z-index: 1000;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        #status {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 10px;
            text-align: center;
            font-weight: bold;
            font-size: 14px;
            z-index: 1000;
            box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.3);
        }

        .connected {
            background-color: #28a745;
            color: white;
        }

        .disconnected {
            background-color: #dc3545;
            color: white;
        }

        #mixer-container {
            position: absolute;
            top: 60px;
            bottom: 50px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        #channels {
            display: flex;
            gap: 40px;
            align-items: center;
            justify-content: center;
            height: 100%;
            max-height: 600px;

            column-gap: 40px;
        }

        .channel-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100%;
        }

        .group-title {
            font-size: 14px;
            font-weight: bold;
            color: #e0e0e0;
            text-align: center;
            margin-bottom: 10px;

            min-height: 5vh;
        }

        .group-channels {
            display: flex;
            gap: 40px;
            align-items: center;
            height: 100%;
            position: relative;
        }

        .group-divider {
            width: 2px;
            height: 70%;
            background: black;
        }

        .channel {
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100%;
            min-width: 80px;
        }

        .channel-label {
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #e0e0e0;
            text-align: center;
            min-height: 5vh;
        }

        .fader-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: stretch;
            position: relative;
            width: 60px;
            margin: 10px 0;
            padding: 10px 0;
        }

        .fader {
            -webkit-appearance: none;
            accent-color: lightgray;
            writing-mode: vertical-rl;
            direction: rtl;
            background: linear-gradient(to top, #4CAF50 0%, #FFC107 50%, #F44336 100%);
            border-radius: 4px;
            width: 10px;
            border: 2px solid black;
            cursor: pointer;
            z-index: 2;
            margin: 0 auto;
        }

        .fader::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 50px;
            height: 30px;
            background: lightgray;
            border: 2px solid #505050;
            border-radius: 4px;
            cursor: pointer;
        }

        .fader::-webkit-slider-thumb:hover {
            background: gray;
        }

        .fader::-webkit-slider-thumb:active {
            background: darkgray;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
        }

        .value-display {
            margin-top: 10px;
            font-size: 16px;
            font-weight: bold;
            color: #4CAF50;
            min-height: 24px;
            font-family: 'Courier New', monospace;
        }

        .cc-number {
            font-size: 11px;
            color: #999;
            margin-top: 5px;
        }
    </style>
</head>
<body>
<div id="header">
    Remote Mixer
</div>

<div id="mixer-container">
    <div id="channels">
        <!-- Channels will be dynamically inserted here -->
    </div>
</div>

<div id="status" class="disconnected">
    Status: Disconnected
</div>

<script>
  window.ws = null;
  window.wsHealthCheckTimeout = null;
  window.rm_config = null;
  window.fadersByCC = {};  // Map of CC values to fader elements
  const statusDiv = document.getElementById('status');
  const channelsContainer = document.getElementById('channels');

  // Load configuration and initialize
  async function initialize() {
    try {
      const response = await fetch('/config');
      window.rm_config = await response.json();

      if (window.rm_config.error) {
        console.error('Config error:', window.rm_config.error);
        return;
      }

      // Create channel groups
      createChannelGroups(window.rm_config.channel_groups);

      // Connect WebSocket
      connect();
    } catch (error) {
      console.error('Failed to load config:', error);
    }
  }

  function createChannelGroups(channelGroups) {
    channelsContainer.innerHTML = '';
    window.fadersByCC = {};  // Reset the map

    channelGroups.forEach((group, index) => {
      const groupDiv = document.createElement('div');
      groupDiv.className = 'channel-group';

      // Add group title if it exists and is not empty
      // if (group.title && group.title.trim()) {
        const groupTitle = document.createElement('div');
        groupTitle.className = 'group-title';
        groupTitle.textContent = group.title;
        groupDiv.appendChild(groupTitle);
      // }

      const channelsDiv = document.createElement('div');
      channelsDiv.className = 'group-channels';

      // Create channels within this group
      group.channels.forEach((channel) => {
        const channelDiv = document.createElement('div');
        channelDiv.className = 'channel';

        const label = document.createElement('div');
        label.className = 'channel-label';
        label.textContent = channel.title;

        const faderContainer = document.createElement('div');
        faderContainer.className = 'fader-container';

        const fader = document.createElement('input');
        fader.type = 'range';
        fader.className = 'fader';
        fader.min = '0';
        fader.max = '127';
        fader.value = '0';  // Start at 0 (bottom position)
        fader.orient = 'vertical';
        fader.dataset.cc = channel.cc;

        const valueDisplay = document.createElement('div');
        valueDisplay.className = 'value-display';
        valueDisplay.textContent = '0';  // Display shows 0 at bottom

        const ccNumber = document.createElement('div');
        ccNumber.className = 'cc-number';
        ccNumber.textContent = `CC ${ channel.cc }`;

        // Store fader and display references for MIDI updates
        window.fadersByCC[channel.cc] = {
          fader: fader,
          valueDisplay: valueDisplay
        };

        // Handle fader changes
        fader.addEventListener('input', (e) => {
          // Direct value - CSS transform flips the slider so 0 is at bottom
          const value = parseInt(e.target.value);
          valueDisplay.textContent = value;

          // Send MIDI CC message via WebSocket
          if (window.ws && window.ws.readyState === WebSocket.OPEN) {
            const message = JSON.stringify({
              type: 'cc',
              cc: channel.cc,
              value: value
            });
            window.ws.send(message);
          }
        });

        faderContainer.appendChild(fader);

        channelDiv.appendChild(label);
        channelDiv.appendChild(faderContainer);
        channelDiv.appendChild(valueDisplay);
        channelDiv.appendChild(ccNumber);

        channelsDiv.appendChild(channelDiv);
      });

      groupDiv.appendChild(channelsDiv);
      channelsContainer.appendChild(groupDiv);

      if (index < channelGroups.length - 1) {
        const groupDivider = document.createElement('div')
        groupDivider.className = 'group-divider';
        channelsContainer.appendChild(groupDivider);
      }
    });

    // channelsContainer.removeChild(.childElementCount
  }

  function connect() {
    const protocol = window.location.protocol === 'https:'
      ? 'wss:'
      : 'ws:';
    const wsUrl = `${ protocol }//${ window.location.host }/ws`;

    cancelHealthCheck();
    window.ws = new WebSocket(wsUrl);

    window.ws.onopen = (event) => {
      console.log('WebSocket connected');
      statusDiv.textContent = 'Status: Connected';
      statusDiv.className = 'connected';
    };

    window.ws.onmessage = (event) => {
      console.log('Message received:', event.data);

      try {
        const data = JSON.parse(event.data);

        // Handle MIDI CC updates from server
        if (data.type === 'midi_cc_update') {
          const cc = data.cc;
          const value = data.value;

          // Update the corresponding fader and display if it exists
          if (window.fadersByCC && window.fadersByCC[cc]) {
            const faderInfo = window.fadersByCC[cc];
            faderInfo.fader.value = value;
            faderInfo.valueDisplay.textContent = value;
            console.log(`Updated slider for CC ${ cc } to value ${ value }`);
          }
        }
      } catch (e) {
        console.log('Received non-JSON message:', event.data);
      }
    };

    window.ws.onerror = function (error) {
      console.error('WebSocket error:', error);
    };

    window.ws.onclose = function (event) {
      console.log('WebSocket disconnected');
      statusDiv.textContent = 'Status: Disconnected';
      statusDiv.className = 'disconnected';

      // Attempt to reconnect after 3 seconds
      setTimeout(connect, 1500);
    };

    scheduleNextHealthCheck();
  }

  function healthCheck() {
    const message = JSON.stringify({
      type: 'healthcheck'
    });
    window.ws.send(message);

    window.wsHealthCheckTimeout = setTimeout(healthCheck, 1500);
  }

  function scheduleNextHealthCheck() {
    window.wsHealthCheckTimeout = setTimeout(healthCheck, 1500);
  }

  function cancelHealthCheck() {
    clearTimeout(window.wsHealthCheckTimeout);
  }

  // Initialize on page load
  window.addEventListener('DOMContentLoaded', initialize);
</script>
</body>
</html>
